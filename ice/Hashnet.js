// **********************************************************************
//
// Copyright (c) 2003-2018 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.1
//
// <auto-generated>
//
// Generated from file `Hashnet.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

/* eslint-disable */
/* jshint ignore: start */

(function(module, require, exports)
{
    const Ice = require("ice").Ice;
    const _ModuleRegistry = Ice._ModuleRegistry;
    const Slice = Ice.Slice;

    let one = _ModuleRegistry.module("one");

    one.inve = _ModuleRegistry.module("one.inve");

    one.inve.rpc = _ModuleRegistry.module("one.inve.rpc");

    one.inve.rpc.bgossip = _ModuleRegistry.module("one.inve.rpc.bgossip");

    const iceC_one_inve_rpc_bgossip_Gossip_ids = [
        "::Ice::Object",
        "::one::inve::rpc::bgossip::Gossip"
    ];

    one.inve.rpc.bgossip.Gossip = class extends Ice.Object
    {
    };

    one.inve.rpc.bgossip.GossipPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(one.inve.rpc.bgossip.Gossip, one.inve.rpc.bgossip.GossipPrx, iceC_one_inve_rpc_bgossip_Gossip_ids, 1,
    {
        "initView": [, , , , , , , , , ],
        "shuffling": [, , , , , [[7]], , , , ]
    });

    one.inve.rpc.seed = _ModuleRegistry.module("one.inve.rpc.seed");

    one.inve.rpc.seed.BaseNode = class
    {
        constructor(pubKey = "", ip = "", rpcPort = 0, gossipPort = 0)
        {
            this.pubKey = pubKey;
            this.ip = ip;
            this.rpcPort = rpcPort;
            this.gossipPort = gossipPort;
        }

        _write(ostr)
        {
            ostr.writeString(this.pubKey);
            ostr.writeString(this.ip);
            ostr.writeInt(this.rpcPort);
            ostr.writeInt(this.gossipPort);
        }

        _read(istr)
        {
            this.pubKey = istr.readString();
            this.ip = istr.readString();
            this.rpcPort = istr.readInt();
            this.gossipPort = istr.readInt();
        }

        static get minWireSize()
        {
            return  10;
        }
    };

    Slice.defineStruct(one.inve.rpc.seed.BaseNode, true, true);

    Slice.defineSequence(one.inve.rpc.seed, "BaseNodeListHelper", "one.inve.rpc.seed.BaseNode", false);

    Slice.defineSequence(one.inve.rpc.seed, "InShardLocalfullnodeListHelper", "one.inve.rpc.seed.BaseNode", false);

    const iceC_one_inve_rpc_seed_Regist_ids = [
        "::Ice::Object",
        "::one::inve::rpc::seed::Regist"
    ];

    one.inve.rpc.seed.Regist = class extends Ice.Object
    {
    };

    one.inve.rpc.seed.RegistPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(one.inve.rpc.seed.Regist, one.inve.rpc.seed.RegistPrx, iceC_one_inve_rpc_seed_Regist_ids, 1,
    {
        "getLocalfullnodeListInShard": [, , , , ["one.inve.rpc.seed.InShardLocalfullnodeListHelper"], [[7]], , , , ],
        "getLocalfullnodeListByShardId": [, , , , ["one.inve.rpc.seed.InShardLocalfullnodeListHelper"], [[7]], , , , ],
        "getShardInfo": [, , , , [7], [[7]], , , , ]
    });

    one.inve.rpc.localfullnode = _ModuleRegistry.module("one.inve.rpc.localfullnode");

    one.inve.rpc.localfullnode.Balance = class
    {
        constructor(stable = 0, pending = 0)
        {
            this.stable = stable;
            this.pending = pending;
        }

        _write(ostr)
        {
            ostr.writeInt(this.stable);
            ostr.writeInt(this.pending);
        }

        _read(istr)
        {
            this.stable = istr.readInt();
            this.pending = istr.readInt();
        }

        static get minWireSize()
        {
            return  8;
        }
    };

    Slice.defineStruct(one.inve.rpc.localfullnode.Balance, true, false);

    one.inve.rpc.localfullnode.Hash = class
    {
        constructor(hash = "", hashMapSeed = 0)
        {
            this.hash = hash;
            this.hashMapSeed = hashMapSeed;
        }

        _write(ostr)
        {
            ostr.writeString(this.hash);
            ostr.writeInt(this.hashMapSeed);
        }

        _read(istr)
        {
            this.hash = istr.readString();
            this.hashMapSeed = istr.readInt();
        }

        static get minWireSize()
        {
            return  5;
        }
    };

    Slice.defineStruct(one.inve.rpc.localfullnode.Hash, true, true);

    Slice.defineSequence(one.inve.rpc.localfullnode, "TransactionHelper", "Ice.ByteHelper", true);

    Slice.defineSequence(one.inve.rpc.localfullnode, "TransactionListHelper", "one.inve.rpc.localfullnode.TransactionHelper", false);

    Slice.defineSequence(one.inve.rpc.localfullnode, "SignatureHelper", "Ice.ByteHelper", true);

    one.inve.rpc.localfullnode.Event = class
    {
        constructor(selfId = new Ice.Long(0, 0), selfSeq = new Ice.Long(0, 0), otherId = new Ice.Long(0, 0), otherSeq = new Ice.Long(0, 0), transactions = null, timeCreated = "", sign = null)
        {
            this.selfId = selfId;
            this.selfSeq = selfSeq;
            this.otherId = otherId;
            this.otherSeq = otherSeq;
            this.transactions = transactions;
            this.timeCreated = timeCreated;
            this.sign = sign;
        }

        _write(ostr)
        {
            ostr.writeLong(this.selfId);
            ostr.writeLong(this.selfSeq);
            ostr.writeLong(this.otherId);
            ostr.writeLong(this.otherSeq);
            one.inve.rpc.localfullnode.TransactionListHelper.write(ostr, this.transactions);
            ostr.writeString(this.timeCreated);
            one.inve.rpc.localfullnode.SignatureHelper.write(ostr, this.sign);
        }

        _read(istr)
        {
            this.selfId = istr.readLong();
            this.selfSeq = istr.readLong();
            this.otherId = istr.readLong();
            this.otherSeq = istr.readLong();
            this.transactions = one.inve.rpc.localfullnode.TransactionListHelper.read(istr);
            this.timeCreated = istr.readString();
            this.sign = one.inve.rpc.localfullnode.SignatureHelper.read(istr);
        }

        static get minWireSize()
        {
            return  35;
        }
    };

    Slice.defineStruct(one.inve.rpc.localfullnode.Event, true, true);

    Slice.defineSequence(one.inve.rpc.localfullnode, "LastSeqOneShardHelper", "Ice.LongHelper", true);

    Slice.defineDictionary(one.inve.rpc.localfullnode, "LastSeqOutshard", "LastSeqOutshardHelper", "Ice.LongHelper", "one.inve.rpc.localfullnode.LastSeqOneShardHelper", false, Ice.HashMap.compareEquals, undefined, Ice.ArrayUtil.equals);

    Slice.defineSequence(one.inve.rpc.localfullnode, "EventListHelper", "one.inve.rpc.localfullnode.Event", false);

    const iceC_one_inve_rpc_localfullnode_Local2local_ids = [
        "::Ice::Object",
        "::one::inve::rpc::localfullnode::Local2local"
    ];

    one.inve.rpc.localfullnode.Local2local = class extends Ice.Object
    {
    };

    one.inve.rpc.localfullnode.Local2localPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(one.inve.rpc.localfullnode.Local2local, one.inve.rpc.localfullnode.Local2localPrx, iceC_one_inve_rpc_localfullnode_Local2local_ids, 1,
    {
        "gossipMyMaxSeqList4Consensus": [, , , , ["one.inve.rpc.localfullnode.EventListHelper"], [[7], [7], ["one.inve.rpc.localfullnode.LastSeqOneShardHelper"]], , , , ],
        "gossipHashGraph4Consensus": [, , , , , [[7], [7], ["one.inve.rpc.localfullnode.EventListHelper"]], , , , ],
        "gossipMyMaxSeqList4Sync": [, , , , ["one.inve.rpc.localfullnode.EventListHelper"], [[7], [7], [3], ["one.inve.rpc.localfullnode.LastSeqOneShardHelper"]], , , , ],
        "gossipHashGraph4Sync": [, , , , , [[7], [7], ["one.inve.rpc.localfullnode.EventListHelper"]], , , , ]
    });

    one.inve.rpc.localfullnode.Ltransaction = class
    {
        constructor(fromAddress = "", toAddress = "", amount = new Ice.Long(0, 0), fee = new Ice.Long(0, 0), unitId = "", time = new Ice.Long(0, 0), isStable = 0)
        {
            this.fromAddress = fromAddress;
            this.toAddress = toAddress;
            this.amount = amount;
            this.fee = fee;
            this.unitId = unitId;
            this.time = time;
            this.isStable = isStable;
        }

        _write(ostr)
        {
            ostr.writeString(this.fromAddress);
            ostr.writeString(this.toAddress);
            ostr.writeLong(this.amount);
            ostr.writeLong(this.fee);
            ostr.writeString(this.unitId);
            ostr.writeLong(this.time);
            ostr.writeInt(this.isStable);
        }

        _read(istr)
        {
            this.fromAddress = istr.readString();
            this.toAddress = istr.readString();
            this.amount = istr.readLong();
            this.fee = istr.readLong();
            this.unitId = istr.readString();
            this.time = istr.readLong();
            this.isStable = istr.readInt();
        }

        static get minWireSize()
        {
            return  31;
        }
    };

    Slice.defineStruct(one.inve.rpc.localfullnode.Ltransaction, true, true);

    Slice.defineSequence(one.inve.rpc.localfullnode, "LtransactionListHelper", "one.inve.rpc.localfullnode.Ltransaction", false);

    Slice.defineSequence(one.inve.rpc.localfullnode, "unitListHelper", "Ice.StringHelper", false);

    const iceC_one_inve_rpc_localfullnode_Light2local_ids = [
        "::Ice::Object",
        "::one::inve::rpc::localfullnode::Light2local"
    ];

    one.inve.rpc.localfullnode.Light2local = class extends Ice.Object
    {
    };

    one.inve.rpc.localfullnode.Light2localPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(one.inve.rpc.localfullnode.Light2local, one.inve.rpc.localfullnode.Light2localPrx, iceC_one_inve_rpc_localfullnode_Light2local_ids, 1,
    {
        "sendMessage": [, , , , [7], [[7]], , , , ],
        "getBalance": [, , , , [one.inve.rpc.localfullnode.Balance], [[7]], , , , ],
        "getTransactionHistory": [, , , , ["one.inve.rpc.localfullnode.LtransactionListHelper"], [[7]], , , , ],
        "getTransactionInfo": [, , , , [one.inve.rpc.localfullnode.Ltransaction], [[7]], , , , ],
        "getUnitInfoList": [, , , , ["one.inve.rpc.localfullnode.unitListHelper"], [[7]], , , , ],
        "getUnitInfo": [, , , , [7], [[7]], , , , ]
    });

    one.inve.rpc.fullnode = _ModuleRegistry.module("one.inve.rpc.fullnode");

    one.inve.rpc.fullnode.Question = class
    {
        constructor(question = "")
        {
            this.question = question;
        }

        _write(ostr)
        {
            ostr.writeString(this.question);
        }

        _read(istr)
        {
            this.question = istr.readString();
        }

        static get minWireSize()
        {
            return  1;
        }
    };

    Slice.defineStruct(one.inve.rpc.fullnode.Question, true, true);

    one.inve.rpc.fullnode.Answer = class
    {
        constructor(answer = "")
        {
            this.answer = answer;
        }

        _write(ostr)
        {
            ostr.writeString(this.answer);
        }

        _read(istr)
        {
            this.answer = istr.readString();
        }

        static get minWireSize()
        {
            return  1;
        }
    };

    Slice.defineStruct(one.inve.rpc.fullnode.Answer, true, true);

    const iceC_one_inve_rpc_fullnode_ApplyFullNode_ids = [
        "::Ice::Object",
        "::one::inve::rpc::fullnode::ApplyFullNode"
    ];

    one.inve.rpc.fullnode.ApplyFullNode = class extends Ice.Object
    {
    };

    one.inve.rpc.fullnode.ApplyFullNodePrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(one.inve.rpc.fullnode.ApplyFullNode, one.inve.rpc.fullnode.ApplyFullNodePrx, iceC_one_inve_rpc_fullnode_ApplyFullNode_ids, 1,
    {
        "requestQuestion": [, , , , [one.inve.rpc.fullnode.Question], , , , , ],
        "submitAnswer": [, , , , , [[7], [7], [one.inve.rpc.fullnode.Answer]], , , , ]
    });

    one.inve.rpc.demo = _ModuleRegistry.module("one.inve.rpc.demo");

    Slice.defineSequence(one.inve.rpc.demo, "EventObjHelper", "Ice.ByteHelper", true);

    const iceC_one_inve_rpc_demo_Printer_ids = [
        "::Ice::Object",
        "::one::inve::rpc::demo::Printer"
    ];

    one.inve.rpc.demo.Printer = class extends Ice.Object
    {
    };

    one.inve.rpc.demo.PrinterPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(one.inve.rpc.demo.Printer, one.inve.rpc.demo.PrinterPrx, iceC_one_inve_rpc_demo_Printer_ids, 1,
    {
        "printString": [, , , , , [[7]], , , , ],
        "add": [, , , , [3], [[3], [3]], , , , ],
        "sub": [, , , , [3], [[3], [3]], [[1], [4]], , , ],
        "printEvent": [, , , , , [["one.inve.rpc.demo.EventObjHelper"]], , , , ]
    });

    Slice.defineSequence(one.inve.rpc.demo, "RowHelper", "Ice.FloatHelper", true);

    Slice.defineSequence(one.inve.rpc.demo, "GridHelper", "one.inve.rpc.demo.RowHelper", false);

    one.inve.rpc.demo.RangeError = class extends Ice.UserException
    {
        constructor(_cause = "")
        {
            super(_cause);
        }

        static get _parent()
        {
            return Ice.UserException;
        }

        static get _id()
        {
            return "::one::inve::rpc::demo::RangeError";
        }

        _mostDerivedType()
        {
            return one.inve.rpc.demo.RangeError;
        }
    };

    const iceC_one_inve_rpc_demo_Model_ids = [
        "::Ice::Object",
        "::one::inve::rpc::demo::Model"
    ];

    one.inve.rpc.demo.Model = class extends Ice.Object
    {
    };

    one.inve.rpc.demo.ModelPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(one.inve.rpc.demo.Model, one.inve.rpc.demo.ModelPrx, iceC_one_inve_rpc_demo_Model_ids, 1,
    {
        "interpolate": [, , , , ["one.inve.rpc.demo.GridHelper"], [["one.inve.rpc.demo.GridHelper"], [5]], ,
        [
            one.inve.rpc.demo.RangeError
        ], , ]
    });
    exports.one = one;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require :
 (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) ? self.Ice._require : window.Ice._require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports :
 (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) ? self : window));
